# Transactions

> 트랜잭션은 어플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다. 트랜잭션은 전체가 성공(COMMIT) 하거나 실패(ABORT)한다.

### ACID의 의미
- ACID
    - Atomicity
    - Consistency
    - Isolation
    - Durability
- BASE: ACID 표준을 따르지 않는 시스템
    - Basically Available
    - Soft state
    - Eventual consistency

### 단일 객체 연산과 다중 객체 연산
- 단일 객체 연산: 여러 클라이언트가 동시에 같은 객체를 쓰려고 할 때 Lost Update를 방지하므로 유용함.
- 다중 객체 트랜잭션: 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요.

### 경쟁 조건의 예시
|이름|설명|방지|
|------|------|------|
|더티 읽기|한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 읽는다.| 커밋 후 읽기 |
|더티 쓰기|한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 덮어쓴다.| 거의 모든 트랜잭션 구현 |
|읽기 스큐|클라이언트는 다른 시점에 데이터베이스의 다른 부분을 본다.| 스냅숏 격리|
|갱신 손실| 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실된다. | 스냅숏 격리 구현 중 일부는 자동으로 막아주지만 그렇지 않으면 수동 잠금(`SELECT FOR UPDATE`)가 필요하다.|
|쓰기 스큐| 트랜잭션이 읽은 값으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓰지만, 쓰기를 실행하는 시점에는 결정의 전제가 더이상 참이 아니다. | 직렬성 격리|
|팬텀 읽기| 트랜잭션이 검색 조건에 부합하는 객체를 읽는 도중 다른 클라이언트가 그 결과에 영향을 주는 쓰기를 실행한다. | 스냅숏 격리는 간단한 팬텀 읽기를 막아주지만 쓰기 스큐 맥락에서는 색인 범위 잠금 처럼 특별한 처리가 필요하다.|

### 동시성 제어
- 커밋 후 읽기
    1. 읽을 때 커밋된 데이터만 보게 된다. (더티읽기 없음)
    2. 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티쓰기 없음)
    - 구현: row 수준 잠금을 사용.
- 스냅숏 격리
    - 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다.
    - 읽는 쪽에서 쓴는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다.
    - 구현: 쓰기잠금을 사용. 읽을 때는 아무 잠금도 필요 없다.
    - **"다중 버전 동시성 제어"** (multi-vresion concurrency control, MVCC)
- 직렬성 격리
    - 여러 트랜젝션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다.
    1. 말 그대로 트랜잭션을 순서대로 실행하기
    2. 2단계 잠금(2-phase locking, 2PL)
    3. 직렬성 스냅숏 격리(SSI)
